{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Limber \u00b6 A python web application framework built using FastAPI. Documentation : https://limber-project.github.io Source Code : https://github.com/limber-project/limber Limber is a python web application framework with the goal of simplifying the development of web applications. It is based on the FastAPI framework and provides services to handle common tasks that are required by web applications. The key features are: Fast setup : quickly setup a new project with many of the services available and configured out of the box. Caching : choose from a range of different caching options already implemented. Authentication : easily authenticate a request using different mechanisms. Database : get up and running fast with SQLAlchemy and Alembic setup out of the box. Rate limiting : protect your API with the throttling middleware.","title":"Welcome"},{"location":"#limber","text":"A python web application framework built using FastAPI. Documentation : https://limber-project.github.io Source Code : https://github.com/limber-project/limber Limber is a python web application framework with the goal of simplifying the development of web applications. It is based on the FastAPI framework and provides services to handle common tasks that are required by web applications. The key features are: Fast setup : quickly setup a new project with many of the services available and configured out of the box. Caching : choose from a range of different caching options already implemented. Authentication : easily authenticate a request using different mechanisms. Database : get up and running fast with SQLAlchemy and Alembic setup out of the box. Rate limiting : protect your API with the throttling middleware.","title":"Limber"},{"location":"application/","text":"Application \u00b6 The Application class, limberframework.foundation.application.Application , is responsible for registering the available services, creating instances of services when needed, and monitoring the instances, i.e. establishing the service container. An example of how to establish a new instance of Application is shown below: from limberframework.foundation.application import Application app = Application() Application inherits from the FastAPI class, fastapi.applications.FastAPI , and, therefore, receives its functionality as well. Services \u00b6 Services provide functionality to the web application and can be registered with Application using a Service Provider , limberframework.support.service_providers.ServiceProvider . A Service Provider has a register() method which is called by Application . This method should bind services to the service container using Application's bind() method, passing a closure that will be called to create the service when required. The closure will have access to Application , and all services that have been registered with Application , as an argument. An example is shown below: from limberframework.foundation.application import Application from limberframework.database.connections import Connection, make_connection from limberframework.support.service_provider import ServiceProvider # Create a service provider that provides the database service. class DatabaseServiceProvider(ServiceProvider): def register(self) -> None: # Closure to create the database service when required. def register_database(app: Application): return make_connection(app['config']['database']) # Bind the service to the service container. self.app.bind('database', register_database) # Create an instance of the database service provider. database_service_provider = DatabaseServiceProvider(app) # Register the services provided by the database # service provider with the service container. app.register(database_service_provider) The database service can be requested from Application as follows: database_service = app.make('database') # or database_service = app['database'] Singletons \u00b6 A service can be register with Application as a singleton, i.e. only having one instance of the service in existence at any time. In this case, Application will monitor all created instances of the service and provide an existing instance if available. Setting a service to a singleton can be achieved by setting the singleton argument of Application's bind() method to True . # Bind the database service as a singleton to the service container. self.app.bind('database', register_database, singleton=True) Deferred \u00b6 Application will pre-load services on start-up of the web application to reduce overhead when handling a request. To prevent a service from being pre-loaded, for example when a fresh instance of a service is required for each request, the service can be set to deferred. This can be achieved by setting the defer argument of Application's bind() method to True . # Bind the database service to the service container and defer loading. self.app.bind('database', register_database, defer=True) Custom Service \u00b6 If you would like to create a service and register it with Application , establish a new service provider that inherits from ServiceProvider , limberframework.support.service_providers.ServiceProvider , and implements the required methods. Also, to let Application know that the service is available, add it to the list of service providers in app's configuration, limber.config.app.service_providers . service_providers = [ 'limberframework.authentication.authentication_service_provider.AuthServiceProvider', 'limberframework.cache.cache_service_provider.CacheServiceProvider', 'limberframework.config.config_service_provider.ConfigServiceProvider', 'limberframework.database.database_service_provider.DatabaseServiceProvider', 'custompackage.custom.custom_service_provider.CustomServiceProvider' ]","title":"Application"},{"location":"application/#application","text":"The Application class, limberframework.foundation.application.Application , is responsible for registering the available services, creating instances of services when needed, and monitoring the instances, i.e. establishing the service container. An example of how to establish a new instance of Application is shown below: from limberframework.foundation.application import Application app = Application() Application inherits from the FastAPI class, fastapi.applications.FastAPI , and, therefore, receives its functionality as well.","title":"Application"},{"location":"application/#services","text":"Services provide functionality to the web application and can be registered with Application using a Service Provider , limberframework.support.service_providers.ServiceProvider . A Service Provider has a register() method which is called by Application . This method should bind services to the service container using Application's bind() method, passing a closure that will be called to create the service when required. The closure will have access to Application , and all services that have been registered with Application , as an argument. An example is shown below: from limberframework.foundation.application import Application from limberframework.database.connections import Connection, make_connection from limberframework.support.service_provider import ServiceProvider # Create a service provider that provides the database service. class DatabaseServiceProvider(ServiceProvider): def register(self) -> None: # Closure to create the database service when required. def register_database(app: Application): return make_connection(app['config']['database']) # Bind the service to the service container. self.app.bind('database', register_database) # Create an instance of the database service provider. database_service_provider = DatabaseServiceProvider(app) # Register the services provided by the database # service provider with the service container. app.register(database_service_provider) The database service can be requested from Application as follows: database_service = app.make('database') # or database_service = app['database']","title":"Services"},{"location":"application/#singletons","text":"A service can be register with Application as a singleton, i.e. only having one instance of the service in existence at any time. In this case, Application will monitor all created instances of the service and provide an existing instance if available. Setting a service to a singleton can be achieved by setting the singleton argument of Application's bind() method to True . # Bind the database service as a singleton to the service container. self.app.bind('database', register_database, singleton=True)","title":"Singletons"},{"location":"application/#deferred","text":"Application will pre-load services on start-up of the web application to reduce overhead when handling a request. To prevent a service from being pre-loaded, for example when a fresh instance of a service is required for each request, the service can be set to deferred. This can be achieved by setting the defer argument of Application's bind() method to True . # Bind the database service to the service container and defer loading. self.app.bind('database', register_database, defer=True)","title":"Deferred"},{"location":"application/#custom-service","text":"If you would like to create a service and register it with Application , establish a new service provider that inherits from ServiceProvider , limberframework.support.service_providers.ServiceProvider , and implements the required methods. Also, to let Application know that the service is available, add it to the list of service providers in app's configuration, limber.config.app.service_providers . service_providers = [ 'limberframework.authentication.authentication_service_provider.AuthServiceProvider', 'limberframework.cache.cache_service_provider.CacheServiceProvider', 'limberframework.config.config_service_provider.ConfigServiceProvider', 'limberframework.database.database_service_provider.DatabaseServiceProvider', 'custompackage.custom.custom_service_provider.CustomServiceProvider' ]","title":"Custom Service"},{"location":"configuration/","text":"Configuration \u00b6 The config folder holds a variety of settings to configure Limber and its services. .env \u00b6 A .env file containing configuration settings can be placed at the root of the project. These settings will then be read and stored in the service container, using the config service, for easy access throughout the project. Custom Configurations \u00b6 To establish new configurations, create a new config class that inherits from limberframework.config.config.BaseConfig . from limberframework.config.config import BaseConfig class RoutesConfig(BaseConfig): pass Inside of the new config class, list the available settings as attributes using Pydantic notation . from typing import Optional from limberframework.config.config import BaseConfig from pydantic import Field class RoutesConfig(BaseConfig): version: Optional[str] = Field(..., env='ROUTES_VERSION') limberframework.config.config.BaseConfig inherits from pydantic.BaseSettings , therefore it receives its functionality as well. Finally, register the new config class with the service container in main.py , limber.main . from limber.config.routes_config import RoutesConfig ... # Load configurations app['config']['app'] = AppConfig().dict() app['config']['auth'] = auth app['config']['cache'] = CacheConfig().dict() app['config']['cors'] = cors app['config']['database'] = DatabaseConfig().dict() app['config']['routes'] = RoutesConfig().dict() ... Now ROUTES_VERSION will be read from the .env file when the web application starts and stored in the service container. app['config']['routes']['version']","title":"Configuration"},{"location":"configuration/#configuration","text":"The config folder holds a variety of settings to configure Limber and its services.","title":"Configuration"},{"location":"configuration/#env","text":"A .env file containing configuration settings can be placed at the root of the project. These settings will then be read and stored in the service container, using the config service, for easy access throughout the project.","title":".env"},{"location":"configuration/#custom-configurations","text":"To establish new configurations, create a new config class that inherits from limberframework.config.config.BaseConfig . from limberframework.config.config import BaseConfig class RoutesConfig(BaseConfig): pass Inside of the new config class, list the available settings as attributes using Pydantic notation . from typing import Optional from limberframework.config.config import BaseConfig from pydantic import Field class RoutesConfig(BaseConfig): version: Optional[str] = Field(..., env='ROUTES_VERSION') limberframework.config.config.BaseConfig inherits from pydantic.BaseSettings , therefore it receives its functionality as well. Finally, register the new config class with the service container in main.py , limber.main . from limber.config.routes_config import RoutesConfig ... # Load configurations app['config']['app'] = AppConfig().dict() app['config']['auth'] = auth app['config']['cache'] = CacheConfig().dict() app['config']['cors'] = cors app['config']['database'] = DatabaseConfig().dict() app['config']['routes'] = RoutesConfig().dict() ... Now ROUTES_VERSION will be read from the .env file when the web application starts and stored in the service container. app['config']['routes']['version']","title":"Custom Configurations"},{"location":"database/","text":"Database \u00b6 SQLAlchemy is used to connect and interact with the DBMS. The database service provider allows access to SQLAlchemy and registers several services with the service container to help with accessing the database, each are discussed below. Connection Service \u00b6 A connection with the database can be established by requesting the db.connection service from the service container, i.e. Application. This will create a new Engine instance which can be used to interact with the database. Session Service \u00b6 A session with the database can be established by requesting the db.session service from the service container, i.e. Application. This will create a new Session instance which can be used to interact with the database. Alembic \u00b6 Limber uses Alembic to version the database using migration scripts. These migration scripts are stored under the database/migrations folder and the Alembic configuration file can be found at the root of the project, alembic.ini . If the location of the migration scripts is changed, update the script_location setting in alembic.ini so that Alembic knows where to find them. To create a new migration script, use the alembic revision command from the root of the project. More information about creating a migration script can be found here . Models \u00b6 Models allow for an association between a database table and Python class to be made and can be found under the app/models folder. Create a New Model \u00b6 To establish a new model, create a new class that inherits from Model , limberframework.database.models.Model . from limberframework.database.models import Model class Book(Model): pass Model is set as the declarative base for SQLAlchemy. Next, describe the table that the class will be associated with using SQLAlchemy notation . from limberframework.database.models import Model from sqlalchemy import Column, Integer, String class Book(Model): id = Column(Integer, primary_key=True) name = Column(String) Finally, register the model in config/app.py under the models list. models = [ 'limber.app.models.user', 'limber.app.models.book' ] Soft Delete \u00b6 To prevent a record from being permanently removed from the database, the soft_delete attribute, along with the delete_at attribute, can be set on a model. class Book(Model): id = Column(Integer, primary_key=True) name = Column(String) deleted_at = Column(DateTime, nullable=True) soft_delete = True Now, when the delete() method is called on Book, the deleted_at field will be updated with the current time and queries will filter out this model.","title":"Database"},{"location":"database/#database","text":"SQLAlchemy is used to connect and interact with the DBMS. The database service provider allows access to SQLAlchemy and registers several services with the service container to help with accessing the database, each are discussed below.","title":"Database"},{"location":"database/#connection-service","text":"A connection with the database can be established by requesting the db.connection service from the service container, i.e. Application. This will create a new Engine instance which can be used to interact with the database.","title":"Connection Service"},{"location":"database/#session-service","text":"A session with the database can be established by requesting the db.session service from the service container, i.e. Application. This will create a new Session instance which can be used to interact with the database.","title":"Session Service"},{"location":"database/#alembic","text":"Limber uses Alembic to version the database using migration scripts. These migration scripts are stored under the database/migrations folder and the Alembic configuration file can be found at the root of the project, alembic.ini . If the location of the migration scripts is changed, update the script_location setting in alembic.ini so that Alembic knows where to find them. To create a new migration script, use the alembic revision command from the root of the project. More information about creating a migration script can be found here .","title":"Alembic"},{"location":"database/#models","text":"Models allow for an association between a database table and Python class to be made and can be found under the app/models folder.","title":"Models"},{"location":"database/#create-a-new-model","text":"To establish a new model, create a new class that inherits from Model , limberframework.database.models.Model . from limberframework.database.models import Model class Book(Model): pass Model is set as the declarative base for SQLAlchemy. Next, describe the table that the class will be associated with using SQLAlchemy notation . from limberframework.database.models import Model from sqlalchemy import Column, Integer, String class Book(Model): id = Column(Integer, primary_key=True) name = Column(String) Finally, register the model in config/app.py under the models list. models = [ 'limber.app.models.user', 'limber.app.models.book' ]","title":"Create a New Model"},{"location":"database/#soft-delete","text":"To prevent a record from being permanently removed from the database, the soft_delete attribute, along with the delete_at attribute, can be set on a model. class Book(Model): id = Column(Integer, primary_key=True) name = Column(String) deleted_at = Column(DateTime, nullable=True) soft_delete = True Now, when the delete() method is called on Book, the deleted_at field will be updated with the current time and queries will filter out this model.","title":"Soft Delete"},{"location":"installation/","text":"Installation \u00b6 This page discusses how to setup a new Limber project. Prerequisites \u00b6 Poetry is required to manage the packages that are needed by Limber. View the Poetry website for information on how to install Poetry. Setup \u00b6 Enter the commands below in a terminal to establish a new Limber project. # Retrieve a fresh instance of Limber git clone https://github.com/limber-project/limber.git cd limber # Install required packages poetry shell poetry install # Run web server uvicorn limber.main:app If you receive an error installing psycopg2 with the message 'ld: library not found for -lssl', view the following stack overflow discussion to find out how to add openssl to your environment for compiling psycopg2.","title":"Installation"},{"location":"installation/#installation","text":"This page discusses how to setup a new Limber project.","title":"Installation"},{"location":"installation/#prerequisites","text":"Poetry is required to manage the packages that are needed by Limber. View the Poetry website for information on how to install Poetry.","title":"Prerequisites"},{"location":"installation/#setup","text":"Enter the commands below in a terminal to establish a new Limber project. # Retrieve a fresh instance of Limber git clone https://github.com/limber-project/limber.git cd limber # Install required packages poetry shell poetry install # Run web server uvicorn limber.main:app If you receive an error installing psycopg2 with the message 'ld: library not found for -lssl', view the following stack overflow discussion to find out how to add openssl to your environment for compiling psycopg2.","title":"Setup"},{"location":"requests/","text":"Requests \u00b6 Several components are involved when processing a request, each are discussed below. Routes \u00b6 Routes can be found under the routes folder, with each module containing a set of routes. A new route can be established inside a route module, as described in the FastAPI docs . Create a New Routes Module \u00b6 To establish a new set of routes, create a new route module in the routes folder. Inside the route module, create a new APIRouter instance. limber.routes.web : from fastapi import APIRouter router = APIRouter() @router.get('/') def root(request: Request): return 'Hello, World!' Next, register the APIRouter with Application in main.py . from limber.routes.web import router as web_router ... # Register routes app.include_router(api_router) app.include_router(web_router) ... Controllers \u00b6 Controllers can be created to handle processing a request and can be found in app/http/controllers . These controllers can be used inside a route as follows: from fastapi import APIRouter, Request from limber.app.http.controllers import welcome_controller router = APIRouter() @router.get('/') def welcome(request: Request): return welcome_controller.get() Middleware \u00b6 Middleware can be used to handle a request before any processing is performed and handle a response before being sent to the client. Middleware can be found in app/http/middleware . These middleware can be register with Application in main.py as follows: from limberframework.database.middleware import DatabaseSessionMiddleware ... app.add_middleware(DatabaseSessionMiddleware) ...","title":"Requests"},{"location":"requests/#requests","text":"Several components are involved when processing a request, each are discussed below.","title":"Requests"},{"location":"requests/#routes","text":"Routes can be found under the routes folder, with each module containing a set of routes. A new route can be established inside a route module, as described in the FastAPI docs .","title":"Routes"},{"location":"requests/#create-a-new-routes-module","text":"To establish a new set of routes, create a new route module in the routes folder. Inside the route module, create a new APIRouter instance. limber.routes.web : from fastapi import APIRouter router = APIRouter() @router.get('/') def root(request: Request): return 'Hello, World!' Next, register the APIRouter with Application in main.py . from limber.routes.web import router as web_router ... # Register routes app.include_router(api_router) app.include_router(web_router) ...","title":"Create a New Routes Module"},{"location":"requests/#controllers","text":"Controllers can be created to handle processing a request and can be found in app/http/controllers . These controllers can be used inside a route as follows: from fastapi import APIRouter, Request from limber.app.http.controllers import welcome_controller router = APIRouter() @router.get('/') def welcome(request: Request): return welcome_controller.get()","title":"Controllers"},{"location":"requests/#middleware","text":"Middleware can be used to handle a request before any processing is performed and handle a response before being sent to the client. Middleware can be found in app/http/middleware . These middleware can be register with Application in main.py as follows: from limberframework.database.middleware import DatabaseSessionMiddleware ... app.add_middleware(DatabaseSessionMiddleware) ...","title":"Middleware"}]}